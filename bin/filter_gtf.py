#! /usr/bin/env python3
from GTF import GTF
import pandas as pd


def filter_by_quantif(g_stats, minCount, minSample, operator):
    # If no filter
    novel_g = g_stats[g_stats["discovery"] == "novel"]
    count_filter = novel_g["validate_by"] < minCount
    sample_filter = novel_g["presents_in_sample"] < minSample

    # If no minCount, filter only by sample
    if not minCount:
        genes = novel_g[sample_filter]

    # If no minSample, filter only by count
    elif not minSample:
        genes = novel_g[count_filter]

    # If neither is None
    else:
        if operator == "or":
            genes = novel_g[count_filter | sample_filter]
        else:
            genes = novel_g[count_filter & sample_filter]

    # Return list of gene_id
    return genes.gene_id.to_list()


def filter_by_struct(g_stats, t_stats, isoform, exon, operator):
    # For each row: extract gene_id and search if this gene_id has at least 1 transcript with 2+ exons
    def check_mono_exons(row):
        gene_id = row["gene_id"]
        # If no row with more than 1 exon : True
        return (
            len(novel_m[(novel_m["gene_id"] == gene_id) & (novel_m["nb_exons"] > 1)])
            < 1
        )

    m = g_stats.merge(t_stats, left_on="gene_id", right_on="gene_id")
    novel_m = m[m["discovery"] == "novel"]

    # Filters
    mono_isoform_filter = novel_m["nb_transcripts"] == 1

    if not exon:
        genes = novel_m[mono_isoform_filter]

    elif not isoform:
        # Only filter exon if selected because takes time
        mono_exon_filter = novel_m.apply(check_mono_exons, axis=1)
        genes = novel_m[mono_exon_filter]

    else:
        mono_exon_filter = novel_m.apply(check_mono_exons, axis=1)
        if operator == "or":
            genes = novel_m[mono_exon_filter | mono_isoform_filter]
        else:
            genes = novel_m[mono_exon_filter & mono_isoform_filter]

    return genes.gene_id.unique().tolist()


def del_genes_in_gtf(gtf, gene_id_list):
    for gene in gene_id_list:
        if gene in gtf:
            del gtf[gene]
    return gtf


def filter_type(string):
    if "|" in string and len(string.split("|")) == 2:
        l = string.split("|")
        l.append("or")
        return l
    elif "&" in string and len(string.split("&")) == 2:
        l = string.split("&")
        l.append("and")
        return l
    else:
        exit(
            'Filter badly formated. Should be in format --filterX="option1|option2" or --filterX="option1&option2".'
        )


# Print filters applied to stdout
def print_filtering_line(arg1, arg2, operator):
    part1 = arg1 if arg1 else ""
    part2 = arg2 if arg2 else ""
    op = f" {operator}" if (arg1 and arg2) else ""
    return f"\tFiltering{part1}{op}{part2} novel genes..."


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Filter your extended GTF generated by ANNEXA. See https://github.com/mlorthiois/annexa for more informations"
    )

    # Required args
    parser.add_argument(
        "--gtf",
        help="Path to extended_annotations.gtf generated by ANNEXA",
        type=argparse.FileType("r"),
        required=True,
    )
    parser.add_argument(
        "--gene_stats",
        help="Path to gene.stats generated by ANNEXA",
        type=argparse.FileType("r"),
        required=True,
    )
    parser.add_argument(
        "--tx_stats",
        help="Path to transcript.stats generated by ANNEXA",
        type=argparse.FileType("r"),
        required=True,
    )

    # Optional args
    parser.add_argument(
        "--filterStruct",
        help="Filter or not mono-isoform and/or mono-exonic genes.",
        choices=["Y&Y", "Y|Y", "Y&N", "Y|N", "N&Y", "N|Y", "N|N"],
        default="N|N",
        type=str,
    )
    parser.add_argument(
        "--filterQuant",
        help="Filter or not genes with less than X read counts and/or present in less than X examples.",
        default="NA|NA",
        type=str,
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Directs the filtered gtf to file with the name of your choice",
        default="extended_annotations.filtered.gtf",
    )
    args = parser.parse_args()

    ###################################################
    # Parse args
    filterStruct = filter_type(args.filterStruct)  # ["N", "Y", "or"]
    # monoIsoform and monoExon are True or False
    monoIsoform = filterStruct[0] == "Y"
    monoExon = filterStruct[1] == "Y"
    operatorStruct = filterStruct[2]

    # minCount and minSample are int or False
    filterQuant = filter_type(args.filterQuant)  # [25, "NA", "and"]
    if filterQuant[0] != "NA":
        try:
            minCount = int(filterQuant[0])
            if not minCount > 0:
                exit("Error in minCount filter: should be a positive number or NA.")
        except:
            exit("Error in minCount filter: should be a positive number or NA.")
    else:
        minCount = False
    if filterQuant[1] != "NA":
        try:
            minSample = int(filterQuant[1])
            if not minSample > 0:
                exit("Error in minSample filter: should be a positive number or NA.")
        except:
            exit("Error in minSample filter: should be a positive number or NA.")
    else:
        minSample = False
    operatorQuant = filterStruct[2]

    ###################################################
    print("PARSING:")
    print(f"\tParsing {args.gene_stats.name}...")
    g_stats = pd.read_csv(args.gene_stats)

    print(f"\tParsing {args.tx_stats.name}...")
    t_stats = pd.read_csv(args.tx_stats)

    print(f"\tParsing {args.gtf.name}...")
    gtf = GTF.parse(args.gtf)

    print(f"\t{len(gtf)} genes identified")
    print(f"\t{len(g_stats[g_stats['discovery']=='novel'])} novel genes identified\n")

    ###################################################
    print("FILTERING:")

    # Filtering by structure
    if monoExon or monoIsoform:
        print(
            print_filtering_line(
                " mono-isoform" if monoIsoform else False,
                " mono-exonic" if monoExon else False,
                operatorStruct,
            )
        )
        geneIds_to_del_struct = filter_by_struct(
            g_stats, t_stats, monoIsoform, monoExon, operatorStruct
        )
    else:
        print("\tPass structure filtering...")
        geneIds_to_del_struct = []

    # Filtering by quantification
    if minSample or minCount:
        print(
            print_filtering_line(
                f" less than {minCount} min count" if minCount else False,
                f" presents in less than {minSample} samples" if minSample else False,
                operatorStruct,
            )
        )
        geneIds_to_del_quant = filter_by_quantif(
            g_stats, minCount, minSample, operatorQuant
        )
    else:
        print("\tPass structure filtering...")
        geneIds_to_del_quant = []

    # Remove duplicate with a set
    to_filter = set(geneIds_to_del_struct + geneIds_to_del_quant)

    # Delete genes in gtf data structure
    filtered_gtf = del_genes_in_gtf(gtf, to_filter)
    print(f"\t{len(to_filter)} novel genes have been filtered\n")

    ###################################################
    ## Create unique list with gene_id to del
    print("WRITING:")
    # Write filtered gtf in output file
    print(f"\tWriting {args.output}...")
    to_write = "\n".join([gene.format_to_gtf() for gene in filtered_gtf.values()])
    with open(args.output, "w") as fd:
        fd.write(to_write)
    print(f"\tWriting complete\n")
    print(f"GTF SUCCESSFULLY FILTERED\n")

    ###################################################
    print("STATS:")
    total = len(filtered_gtf)
    new_genes = len(g_stats[g_stats["discovery"] == "novel"]) - len(to_filter)
    print(f"\t{total} total genes")
    print(f"\t{total-new_genes} known genes")
    print(f"\t{new_genes} novel genes")

    ###################################################
